package study.erik.algorithm.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author erik.wang
 * @date 2020-03-03 22:38
 * @description
 */
public class Generator {

    public static List<String> getKeys() {
        String content = "This article assumes you are comfortable with Spring Boot and REST APIs. It will help you integrate MyBatis in your Spring-Boot project and develop some example interactions with a MySQL database. At the end of this tutorial you will have all you need to create basic interactions with a relational database (including transactions and pool size limits) and unit-test those interactions with an in-memory database." +
                "Mappers are the interfaces that allow us to map an SQL query to a Java method. There are two types of mappings: annotation-driven (simplest) and XML (better for complex and/or dynamic queries). We will explore both in this tutorial, but lets start with the simpler annotation-driven mapping." +
                "The structure of each method is fairly simple and will look familiar to those of you who know Hibernate: the query in the annotation is bound to the Java method. You can now autowire the mapper into another class to call query your database. Let’s try that now." +
                "That’s it for now. Of course like all Spring features, there are a thousand-and-one configuration options for transaction management, but the data source configuration we wrote at the beginning of this article is enough to give Spring the means to create transactions at the method level, which is where we want them." +
                "This is the first of a series of posts on preparing for and understanding interviews at big tech companies, drawing from my experience recruiting and interviewing for Google. I’ll be using real banned interview problems I and other Google engineers have used in interviews. I want to prepare you for the sorts of questions you’ll be asked and give you insight into how your responses will be evaluated (or at least how I personally evaluated various responses I’ve seen in the past)." +
                "Before we dive into the questions, though, a quick introduction to how these interviews work. Keep in mind, this is all my personal perspective as an interviewer, so your mileage may vary. As always, Google recruiters are the authoritative sources, so if you have access to one, ask them first!" +
                "After each interview is done, the interviewer writes up feedback. For entry-level technical roles, this feedback is only on your technical abilities: How well did you apply your data structures and algorithms knowledge? How well do you code? Did your solutionForHouseRobber1 handle all the edge cases? How close did your solutionForHouseRobber1 get to optimal time and space complexity for the problem? How well did you communicate your thoughts and respond to questions?" +
                "If you’re a student or otherwise applying to tech jobs, my hope is that you’ll come away from reading this with a better understanding of what to expect from interview problems. If you’re an interviewer, I’d like to share my thought process and stylistic approach to interviewing, the better to inform others and solicit comments." +
                "Another crucial point: you will not have access to a compiler, shell, repl, or IDE. Phone screens are conducted in a shared Google Docs document. On-site interviews give you the option of either writing by hand on a whiteboard or typing on a laptop into a text editor. You’ll have no tools except yourself and your wits." +
                "Note I’ll be writing code in Python. I like Python because it’s easy to learn, compact, and has an absolutely massive standard library. Candidates like it, too: even though we impose no language constraints, 90% of people I interview use Python. Also I use Python 3 because c’mon, it’s 2018." +
                "Imagine you place a knight chess piece on a phone dial pad. This chess piece moves in an uppercase “L” shape: two steps horizontally followed by one vertically, or one step horizontally then two vertically:" +
                "Every interview I conduct basically breaks down into two parts: first we find an algorithmic solutionForHouseRobber1 and then the candidate implements it in code. I say “we” find a solutionForHouseRobber1 because I’m not a mute spectator: 45 minutes is not a lot of time to design and implement anything under the best circumstances, never mind under pressure. I let candidates take the lead in the discussion, generating ideas, solving instances of the problem, etc., but I’m more than happy to give a nudge in the right direction. The better the candidate, the fewer hints I tend to have to give, but I have yet to see a candidate who required no input from me at all." +
                "I should underscore this, because it’s important: as an interviewer, I’m not in the business of sitting back and watching people fail. I want to write as much positive feedback as I can, and I try to give you opportunities to allow me to write good things about you. Hints are my way of saying “okay, I’m gonna give this bit to you, but only so you can move on and show me what you’ve got on the other parts of the question.”\n" +
                "With that being said, your first action after hearing the question should be stepping up to the whiteboard and solving small instances of the problem by hand. Never dive right into code! Solving small instances lets you spot patterns, observed and edge cases, and also helps crystallize a solutionForHouseRobber1 in your head. As an example, suppose you start on 6 and have two hops to make. Your sequences will be…\n" +
                "One of the surprises I had when I started using this problem is how often candidates get stuck on computing the keys to which we can hop from a given position, also known as the neighbors. My advice is: when in doubt, write an empty placeholder and ask the interviewer if you can implement it later. This problem’s complexity does not lie in the neighbor computation; I’m paying attention to how well you count full numbers. Any time spent on neighbor computation is effectively wasted." +
                "How can we count phone numbers without generating them? It can be done, but not without an additional insight. Notice how the count of numbers that can be generated from a given starting position in N hops is equal to the sum of the counts of hops that can be generated starting from each of its neighbors in N-1 hops. Stated mathematically as a recurrence relation, it looks like this:" +
                "How does one arrive at this insight, you might ask? If you’ve studied recursion, this should become evident after some exploration on the whiteboard. Many candidates who’ve practiced recursion immediately notice this problem breaks down into smaller subproblems, which is a dead giveaway. If you’re in an interview with me and you can’t seem to arrive at this insight, I will usually give hints to help get you there, up to and including outright giving it away if prodding fails." +
                "This next question is one you’re going to be hearing a lot from me: what is the Big-O complexity of this solutionForHouseRobber1? For those who don’t know, Big-O complexity is (informally) a sort of shorthand for the rate at which the amount of computation required by a solutionForHouseRobber1 grows as a function of the size of the input. For this problem, the size of the input is the number of hops. If you’re interested in the proper mathematical definition, you can read more here." +
                "Can we do better? Using only the mathematical relation above and nothing else, not really. One of the reasons I love this problem, though, is it features layers of insight that yield more and more efficient solutions. To find the next one, let’s map out the function calls this function makes. Let’s consider the case of count_sequences(6, 4). Note I use C as the function name for brevity:";

        String[] words = content.split(" ");
        return Arrays.asList(words);
    }

}
