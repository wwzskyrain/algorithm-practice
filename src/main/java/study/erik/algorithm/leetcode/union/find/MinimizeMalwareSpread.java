/**
 * Alipay.com Inc.
 * Copyright (c) 2004-2022 All Rights Reserved.
 */
package study.erik.algorithm.leetcode.union.find;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;
import study.erik.algorithm.util.ArrayUtils;
import study.erik.algorithm.util.LetCodeCommit;

import java.util.Arrays;

/**
 * @author yueyi
 * @version : MinimizeMalwareSpread.java, v 0.1 2022年11月05日 13:37 yueyi Exp $
 */
@RunWith(Parameterized.class)
@LetCodeCommit(title = "924. Minimize Malware Spread",
        selfRemark = "并查集，不是难题，至少比难dp题目可以理解多了。"
                + "不过题意本身也有点绕")
public class MinimizeMalwareSpread {



    int p[];

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        p = new int[n];
        for (int i = 0; i < p.length; i++) {
            p[i] = i;
        }
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    union(i, j);
                }
            }
        }
        //簇的大小，其实最差情况才有n个簇
        int[] setSize = new int[n];
        for (int i : p) {
            setSize[find(i)]++;
        }
        int[] malSCount = new int[n]; // 簇（set）的维度统计坏节点
        for (int malNode : initial) {
            int setIdx = find(malNode);
            malSCount[setIdx]++;
        }
        int res = -1;
        Arrays.sort(initial);
        int maxSizeForMalSet = 0; //最大的坏簇的大小，坏簇——含有坏节点的簇
        for (int malNode : initial) {
            int setIdx = find(malNode);
            int c = malSCount[setIdx];
            // 这个坏点所在的簇中只有一个坏点
            if (c == 1 && setSize[setIdx] > maxSizeForMalSet) {
                maxSizeForMalSet = setSize[setIdx];
                res = malNode;
            }
        }
        return res != -1 ? res : initial[0];

    }

    private int find(int i) {
        // 不想用递归来实现
        while (p[i] != i) {
            int tempI = i;
            i = p[i];
            p[tempI] = p[i];
        }
        return i;
    }

    private void union(int i, int j) {
        int pI = find(i);
        int pJ = find(j);
        p[pI] = pJ;
    }

    @Parameter
    public int[][] graph;
    @Parameter(1)
    public int[]   initial;
    @Parameter(2)
    public int     expect;

    @Parameters
    public static Object[][] data() {
        return new Object[][] {
                {ArrayUtils.buildArray2Dimension("[[1,1,0],[1,1,0],[0,0,1]]"), ArrayUtils.buildArray("[0,1]"), 0},
                {ArrayUtils.buildArray2Dimension("[[1,0,0],[0,1,0],[0,0,1]]"), ArrayUtils.buildArray("[0,2]"), 0},
                {ArrayUtils.buildArray2Dimension("[[1,1,1],[1,1,1],[1,1,1]]"), ArrayUtils.buildArray("[1,2]"), 1},
        };
    }

    @Test
    public void test_() {
        Assert.assertEquals(expect, minMalwareSpread(graph, initial));
    }
}