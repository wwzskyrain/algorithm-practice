/**
 * Alipay.com Inc.
 * Copyright (c) 2004-2022 All Rights Reserved.
 */
package study.erik.algorithm.leetcode.union.find;

import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import study.erik.algorithm.util.LetCodeCommit;

/**
 * @author yueyi
 * @version : MinimizeMalwareSpreadII.java, v 0.1 2022年11月06日 21:37 yueyi Exp $
 */
@RunWith(Parameterized.class)
public class MinimizeMalwareSpreadII {

    @LetCodeCommit(title = "928. Minimize Malware Spread II",
            selfRemark = "这里是用dfs来算被感染集合的大小，还可以用用并查集(Disjoint Set Union)。"
                    + "而答案还需要一下思路：找打那个毒节点，它只感染了一个集合，而且是这类集合中数量最大那个。"
                    + "所以这里的需要使用的并查集的聚簇功能和计算簇大小的功能，对第二个功能的依赖就是这个题目比它的"
                    + "原版I题目的不同之处")
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length, ans = initial[0], max = 0;
        boolean[] infected = new boolean[n];
        for (int u : initial) {infected[u] = true;}
        for (int u : initial) {
            boolean[] visited = new boolean[n];
            visited[u] = true;
            int count = 0;
            for (int i = 0; i < n; i++) {
                if (!visited[i] && graph[u][i] == 1) {
                    count += dfs(graph, i, visited, infected);
                }
            }
            if (count > max || count == max && u < ans) {
                max = count;
                ans = u;
            }
        }
        return ans;
    }

    private int dfs(int[][] graph, int u, boolean[] visited, boolean[] infected) {
        if (infected[u]) {return 0;}
        visited[u] = true;
        int count = 1;
        for (int v = 0; v < graph[u].length; v++) {
            if (!visited[v] && graph[u][v] == 1) {
                int c = dfs(graph, v, visited, infected);
                if (c == 0) {
                    infected[u] = true;
                    return 0;
                }
                count += c;
            }
        }
        return count;
    }

}