/** * Alipay.com Inc. * Copyright (c) 2004-2021 All Rights Reserved. */package study.erik.algorithm.leetcode.tree;import org.junit.Test;import study.erik.algorithm.leetcode.util.TreeNode;import study.erik.algorithm.util.LetCodeCommit;import java.util.ArrayList;import java.util.Deque;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Set;/** * @author yueyi * @version : FindDuplicateSubtrees.java, v 0.1 2021年10月17日 1:50 下午 yueyi Exp $ */public class FindDuplicateSubtrees {    public List<TreeNode> findDuplicateSubtrees1(TreeNode root) {        List<TreeNode> res = new LinkedList<>();        postorder(root, new HashMap<>(), res);        return res;    }    /**     * 这种编码方式确实可以唯一编码吗？     *     * @param cur     * @param map     * @param res     * @return     */    public String postorder(TreeNode cur, Map<String, Integer> map, List<TreeNode> res) {        if (cur == null) {            return "#";        }        String serial = cur.val + "," + postorder(cur.left, map, res) + "," + postorder(cur.right, map, res);        map.put(serial, map.getOrDefault(serial, 0) + 1);        if (map.get(serial) == 2) {            res.add(cur);        }        return serial;    }    @LetCodeCommit(title = "652. Find Duplicate Subtrees",            selfRemark = "以下是我的写法，绝对的严谨而且也应该正确，就是效率低的很很。"                    + "这里有个问题就是如何标识一颗二叉树。我这个解法中，是按照节点去比对的，非常的严谨。"                    + "还有一个思路，就是讨论区中给的，就是用字符串给二叉树编码，理论上也是可以的")    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {        List<TreeNode> result = new ArrayList<>();        Deque<TreeNode> stack = new LinkedList<>();        // preorder non-recursive travel binary tree.        TreeNode p = root;        while (p != null || !stack.isEmpty()) {            if (p != null) {                // 先序访问                if (containsSubtree(p, root)) {                    final TreeNode finalP = p;                    boolean hasContains = result.stream().anyMatch(node -> sameTree(node, finalP));                    if (!hasContains) {                        result.add(finalP);                    }                }                stack.addLast(p);                p = p.left;                continue;            }            TreeNode topNode = stack.removeLast();            p = topNode.right;        }        return result;    }    /**     * 在targetTree中是否有包含originTree     *     * @param originTree     * @param targetTree     * @return     */    private boolean containsSubtree(TreeNode originTree, TreeNode targetTree) {        if (originTree == targetTree) {            return false;        }        return sameTree(originTree, targetTree) ||                (targetTree != null && containsSubtree(originTree, targetTree.left)) ||                (targetTree != null && containsSubtree(originTree, targetTree.right));    }    private boolean sameTree(TreeNode oneTree, TreeNode twoTree) {        if (oneTree == twoTree) {            return true;        }        if (oneTree != null && twoTree != null &&                oneTree.val == twoTree.val &&                sameTree(oneTree.left, twoTree.left) &&                sameTree(oneTree.right, twoTree.right)) {            return true;        }        return false;    }    @Test    public void test_() {        //System.out.println(null == null);        TreeNode treeNode = TreeNode.buildTree("1,2,3,4,null,2,4,null,null,4");        List<TreeNode> duplicateSubtrees = findDuplicateSubtrees(treeNode);        System.out.println(duplicateSubtrees);        TreeNode treeNode2 = TreeNode.buildTree("2,2,2,3,null,3,null");        List<TreeNode> duplicateSubtrees1 = findDuplicateSubtrees(treeNode2);        System.out.println(duplicateSubtrees1);    }}