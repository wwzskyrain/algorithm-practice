/** * Alipay.com Inc. * Copyright (c) 2004-2021 All Rights Reserved. */package study.erik.algorithm.leetcode.tree;import org.junit.Test;import study.erik.algorithm.leetcode.util.TreeNode;import study.erik.algorithm.util.ArrayUtils;import study.erik.algorithm.util.LetCodeCommit;import java.util.Arrays;/** * @author yueyi * @version : ConstructBinarySearchTreeFromPreorderTraversal.java, v 0.1 2021年10月14日 7:52 上午 yueyi Exp $ */public class ConstructBinarySearchTreeFromPreorderTraversal {    @LetCodeCommit(title = "1008. Construct Binary Search Tree from Preorder Traversal",    selfRemark = "构造bst树的题目。关键点就是快速区分左子树和右子树。"            + "用二分法查找。"            + "好久没刷题，竟然连自家的二分法都用错了。"            + "错误点：toIndex是exclusive的。")    public TreeNode bstFromPreorder(int[] preorder) {        return constructBst(preorder, 0, preorder.length - 1);    }    private TreeNode constructBst(int[] preorder, int low, int high) {        if (low > high) {            return null;        }        if (low == high) {            return new TreeNode(preorder[low]);        }        TreeNode root = new TreeNode(preorder[low]);        int rootValue = preorder[low];        int foundIndex = Arrays.binarySearch(preorder, low + 1, high + 1, rootValue);        int insertIndex = -(foundIndex + 1);        root.left = constructBst(preorder, low + 1, insertIndex - 1);        root.right = constructBst(preorder, insertIndex, high);        return root;    }    @Test    public void test() {        bstFromPreorder(ArrayUtils.buildArray("[4,2]"));        bstFromPreorder(ArrayUtils.buildArray("[8,5,1,7,10,12]"));    }}