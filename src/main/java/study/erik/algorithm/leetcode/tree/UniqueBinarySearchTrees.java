/** * Alipay.com Inc. * Copyright (c) 2004-2021 All Rights Reserved. */package study.erik.algorithm.leetcode.tree;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameter;import org.junit.runners.Parameterized.Parameters;import study.erik.algorithm.util.LetCodeCommit;import java.util.HashMap;import java.util.Map;/** * @author yueyi * @version : UniqueBinarySearchTrees.java, v 0.1 2021年11月08日 9:45 上午 yueyi Exp $ * // https://leetcode.com/problems/unique-binary-search-trees/ */@RunWith(Parameterized.class)public class UniqueBinarySearchTrees {    @LetCodeCommit(title = "96. Unique Binary Search Trees")    public int numTrees(int n) {        //return numTreesWithMember(n, new HashMap<>());        return numTreesWithIterate(n, new HashMap<>());    }    /**     * 用备忘录的来解，也很快的.     * 没想到这么快，100%的成绩，而且空间时94%的成绩     *     * @param n     * @param map k=n, v=bst 的个数，也就是问题的解     * @return     */    private int numTreesWithMember(int n, Map<Integer, Integer> map) {        Integer nums = map.get(n);        if (nums != null) {            return nums;        }        int result = 0;        if (n < 2) {            result = 1;        } else {            for (int i = 0; i < n; i++) {                result += numTreesWithMember(i, map) * numTreesWithMember(n - 1 - i, map);            }        }        map.put(n, result);        return result;    }    private int numTreesWithIterate(int n, Map<Integer, Integer> map) {        int[] result = new int[n + 1];        result[0] = result[1] = 1;        for (int i = 2; i < result.length; i++) {            for (int j = 0; j < i; j++) {                result[i] += result[j] * result[i - 1 - j];            }        }        return result[n];    }    @Parameter(0)    public int n;    @Parameter(1)    public int expect;    @Parameters    public static Object[][] data() {        return new Object[][] {                {3, 5}, {1, 1},        };    }    @Test    public void test_() {        Assert.assertEquals(expect, numTrees(n));    }}