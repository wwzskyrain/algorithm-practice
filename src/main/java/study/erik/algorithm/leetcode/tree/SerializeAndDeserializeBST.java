/** * Alipay.com Inc. * Copyright (c) 2004-2021 All Rights Reserved. */package study.erik.algorithm.leetcode.tree;import org.junit.Test;import study.erik.algorithm.leetcode.util.TreeNode;import study.erik.algorithm.util.ArrayUtils;import study.erik.algorithm.util.LetCodeCommit;import java.util.ArrayList;import java.util.Arrays;import java.util.Deque;import java.util.LinkedList;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;/** * @author yueyi * @version : SerializeAndDeserializeBST.java, v 0.1 2021年10月17日 8:32 上午 yueyi Exp $ */public class SerializeAndDeserializeBST {    @LetCodeCommit(title = "449. Serialize and Deserialize BST")    // Encodes a tree to a single string.    public String serialize(TreeNode root) {        List<Integer> nodes = new ArrayList<>();        Deque<TreeNode> stack = new LinkedList<>();        TreeNode p = root;        while (p != null || !stack.isEmpty()) {            if (p != null) {                nodes.add(p.val);                stack.addLast(p);                p = p.left;                continue;            }            TreeNode top = stack.removeLast();            p = top.right;        }        return nodes.stream().map(String::valueOf).collect(Collectors.joining(","));    }    // Decodes your encoded data to tree.    public TreeNode deserialize(String data) {        if (data.length() == 0) {            return null;        }        Integer[] nodeValues = Stream.of(data.split(",")).map(Integer::valueOf).toArray(Integer[]::new);        return doDeserialize(nodeValues, 0, nodeValues.length - 1);    }    private TreeNode doDeserialize(Integer[] nodeValues, int from, int to) {        if (from > to) {            return null;        }        if (from == to) {            return new TreeNode(nodeValues[from]);        }        Integer rootValue = nodeValues[from];        TreeNode root = new TreeNode(rootValue);        int found = Arrays.binarySearch(nodeValues, from + 1, to + 1, rootValue);        int insertIndex = -(found + 1);        root.left = doDeserialize(nodeValues, from + 1, insertIndex - 1);        root.right = doDeserialize(nodeValues, insertIndex, to);        return root;    }    @Test    public void test() {    }}