# 1.dp的常见分类
看到leetcode的diss区有一篇总结：https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.
我于是也想写一下自己对这方面的理解：
1.  背包问题
2.  最长子序列问题
3.  最短路径问题
4.  斐波那契额问题


# 2.总的概述


# 3.具体方案
## 3.1 斐波那契问题

## 3.2 最短路径

## 3.3 最长子序列问题

## 3.4 背包问题
1.  子集和问题也是一个背包问题
2.  组合问题都可以用背包解法解答吗？
3.  背包问题不就是一个组合问题吗？
4.  组合问题可以dfs解答吗？

## 3.5 区间dp
1.  有一类dp是区间dp，比如合并石子，再比如大学算法分析与设计中讲的'矩阵连乘'；其中，合并石子根据规则合并规模不同，难度增加；
    比如，最简单的是两两合并，再来就是K个邻接堆合并；等
2.  例题链接：
    1.  [K个邻接堆合并的 1000 Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/)
    2.  [扎气球 312 Burst Balloons](https://leetcode.com/problems/burst-balloons/)
3.  这类题目不好做，甚至用到3维dp；不过可以先把问题分析清楚。这里只分析K个邻接堆合并的问题
4.  分析是源自这篇文章的：https://leetcode.com/problems/minimum-cost-to-merge-stones/discuss/247657/JAVA-Bottom-Up-%2B-Top-Down-DP-With-Explaination
5.  文章循序渐进，从K=2讲起，用二位dp做出来。然后然后泛化到K，引入第三位变量k，dp[i][j]k]表示把(i,...,j)以K的节奏合并成k堆，需要的最小代价。
    dp[i][j][k] = min(dp[i][s][t]+dp[s+1][j][k-t], 其中s属于[i,j),
    t属于[1,k-1]}),所以，这里有时一个两层循环，加上i，j，k，一共五层循环，可怕。
    文中把这个两层循环简化成了一层循环。其中简化的原理是我是不能理解的，算了。

6.  另外一个分析思路，是lee大神的一种作答；利用一个巧妙的dp设定，用二位dp就完美解答。思路是这样的：
7.  dp[i][j]表示把(i，j)按照K的节奏，尽可能归拢成小于等于K的堆时的最小代价。当然，小于K对之后，就不可能在做归拢操作了。
    如果刚好归拢成K堆，就以再进一步归拢为1堆。所以，在可归拢成一堆的情况下，累加上sum(i,j)就好了，代码如下
    ```
    //dp[i][j]=0
    for (int m = K; m <= l; ++m) {
        for (int i = 0; i + m <= l; ++i) {
            int j = i + m - 1;
            dp[i][j] = Integer.MAX_VALUE;
            for (int mid = i; mid < j; mid += K - 1) {
                dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + 1][j]);
            }
            //真正的合并
            if ((j - i) % (K - 1) == 0) {
                dp[i][j] += prefixSum[j] - prefixSum[i] + stones[i];
            }
        }
    }
    ```

8.  区间dp小结：
    1.  三位dp至少要回分析；
    2.  三位dp不会写自底向上的code，至少应该会写自顶向下的code，这一点还不会
    3.  有时候，可以通过旁边的设定来简化问题，很多时候会是一个不错的思路。


