# 1.字符串匹配算法
本文讲解计算机中字符串"完全匹配算法"；而正则表达式，在我们看来是另外一种更高级别的字符串匹配算法，这里不会涉及。

# 2.问题提出和解题思路
1.  问题：在目标字符串target(也叫主串，简称t)中，问是否包含模式串(也叫子串)pattern（简称p），如果存在，请返回第一个这样的子串的首字母的下标——第一个子串的位置。
2.  问题讲解：java中的findFirst是如何实现的呢？
3.  传统解题思路：

## 2.1 kmp算法
1.  特点：基于传统解题思路，从前往后一个字符一个字符比较，比较失败后，主串i的步幅会根据一个状态机而增加
2.  思路是这样，实现有两种，
    思路一：一个是根据模式串来构建一个一维的数组，skip[j] 表示如果pattern[j]匹配失败，主串i的步幅
    思路二：构件一个确定有限状态自动机，完全用'状态机'的思路去解题。用主串的字符c去'刺激'状态机，一直到状态机到达了终态或者主串字符花费完毕

## 2.2 sunday算法
1.  请看代码吧：study.erik.algorithm.ds.string.Sunday
2.  特点：简单，从前往后，启发式算法。
3.  何为启发式算法：就是必要不充分算法，因为不充分，所以不准确，所以需要有个准确的措施配合它。或者说，可以类比为'定性分析'
4.  复杂性分析：当重复性很好的时候，其时间复杂度O(targetLen/patternLen)

## 2.3 宝页猫算法
1.  有两个算法，一个是坏字符算法，一个是好后缀算法。
2.  坏字符算法：从后往前比较，
3.  好后缀算法：不在描述
4.  两个算法可以同时使用，以最大化每次i的步幅。

## 2.4 小结
写的有点水了，不过还是要来一个总结的；
1.  sunday算法和坏字符算法是很相似的，都是启发式算法，只是匹配的方向不同，前者是从前向后，后者是从后向前
2.  在坏字符算法的基础上，可以仿照kmp算法(开毛片算法)，构造出好后缀算法的。
3.  kmp算法是最让我们激动的，特别是第一种算法实现，因为它完美的使用了递归思想；
    第二种状态机呢，也是非常完美的算法，因为它用起来非常简单，只是构造状态机的时候，有点复杂，不过也是用了递归思想，完美；  


# 扩展
1.  kmp的第二种是实现，是用状态机的；正则表达式的实现也是用状态机的，在《算法》又实现的，这个有空可以看看