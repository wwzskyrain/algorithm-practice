# 1.立意

记录一些我了解的高级数据结构；

## 2.树形数组

首先，它是一个数组，而其中的元素之间是有父子关系的——准确讲是前驱关系，因为结点可以有多个父节点，不对，是多个前驱节点。

首先来熟悉一个操作，lowbit(x) = x&(-x)。它能找到只有x的最右边的1组成的二进制数。比如下面这张表

x | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16
--- | --- | --- | --- | --- | ---| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
binary | 1 | 10 | 11 | 100 | 101 | 110 | 111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 | 10000
lowbit(x) | 1 | 2 | 1 | 4 | 1 | 2 | 1 | 8 | 1 | 2 | 1 | 4 | 1 | 2 | 1 | 16

1. 查找
    1. 查找的是a1，a2，a3...,an的和；
2. 添加
    1. 添加时会更新当前节点的额所有前驱
3. 个人理解
    1. tree[n]中存放的不一定是sum(a1,a2,...,an)，sum(a1,a2,...,an)是通过查找操作获取的
    2. 树形数组其实是一种前缀思想，但是它的威力不在于普普通通的求和，而是在于不断更新中的求和。

## 3. 线段树

## 4.并查集

1. 经典题目：
    1.

## 5.FenwickTree 或者叫做 BinaryIndexTree

介绍：用这个结构来求preSum的。代码如下

```java
private static class Tree {
    private int[] s;

    public Tree(int[] nums) {
        s = new int[nums.length + 1];
    }

    /**
     * index = (nums的i)+1
     *
     * @param index s中的index
     * @param delta 相对已原数组data[i]的delta.
     */
    public void update(int index, int delta) {
        while (index < s.length) {
            s[index] += delta;
            index += lowBit(index);
        }
    }

    /**
     * 查询前缀和，相对于原数组nums，不包含i；
     *
     * @param i
     * @return
     */
    public int queryPreSum(int i) {
        int preSum = 0;
        while (i > 0) {
            preSum += s[i];
            i -= lowBit(i);
        }
        return preSum;
    }

    private int lowBit(int x) {
        return x & (-x);
    }
}

```

具体题目：
1. medium `307. Range Sum Query - Mutable`