# 概述
LXS中的X是变量，目前需要了解的如下：
1. LCS（longest common subsequence）最长公共子序列
2. LIS（longest increasing sequence）最长自增子序列

注意，LXS中的S是subsequence（子串）而不是subarray（子数组）

# 1.LCS最长公共子序列
求数组d1和d2的LCS。

## 1.1 解法（动态规划）
1. 该解法是O(n2)，可以解决10^5范围
2. 该解法无视有重复元素。


# 2.LIS 最长递增子序列
求数组d1中的最长递增子序列。

## 1.1 转化为LCS
解法思路：
1. d2为d1的排序版本
2. 求d1与d2的最长公共子序列

算法特征：
1. 时间复杂度：max(O(n^2)【LCS】, O(nlogn)【排序) = O(n^2)【LCS】
2. 适用于有重复元素

## 1.2 动态规划
思路：
1. 定义dp[i]为d[i]为结尾的最长递增子序列的长度。
2. 则dp[i] = max(dp[j]) + 1 , 其中 j 属于 [0,...,i-1],条件是 d[j] < d[i]
3. 然后ans = dp[i], 其中 i 属于[0,...,n-1]。

算法特性：
1. 时间复杂度： O(n^2)
2. 适用于有重复元素

## 1.3 排序法
思路：
1. 定义l[i]是当前l.length长度递增子序列的结尾元素(值).
2. 当有新元素d[i+1]的时候，判断d[i+1]在l[i]的插入位置，并直接赋值给到该位置(如果位置为l.length，则对应的是添加d[i+1]到l的length位置，从而l的长度增加1)。
3. 为什么要赋值替换，因为这样表示在当前长度length有更小的结尾元素。
4. 为什么要赋值替换而不是插入，从而把插入位置后面的元素右移一个单位？因为不符合l的定义。

算法特性：
1. 时间复杂度： O(nlogn)，主要是二分查找的空间复杂度。
2. 适用于有重复元素
