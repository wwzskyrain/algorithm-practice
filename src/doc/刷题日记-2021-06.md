# 目标
1. 刷题30道

# 实践

## 1.construct-binary-tree-from-inorder-and-postorder-traversal
1. 题目：构造二叉树-给了中序和后续

## 2.Continuous Subarray Sum
1.  题目：求数组中是否存在子数组，其sum能整除k
2.  解题误区：
    1.  滑动窗口解法失败。因为其条件不具有单调性
    2.  比如数组 [2,2,4,6,6]和k=7
    3.  当窗口是 (2，2，4)时，sum为8，可以预见，在加上后面的第一个6，sum=14
        就能满足 mod 7 == 0 了。
    4.  但是窗口 （2，2，4）的sum=8，大于了7，会被移除第一个元素，
        剩下了（2，4）。再加上后面的6的话，mod7=2，不满足要求的。
    5.  所以说窗口的逻辑值不满足单调性。从而不适合滑动窗口


## 3.Ones and Zeroes 
1.  题目：一组01字符串，一个二维容器，大小是：0维度是m，1维度是n，求最多可以装几个这样的01字符串
2.  解题：
    1.  一维的01背包问题必须知道递推公市：
        1.  f[i,C] = max(f[i-1,C], f[i-1,[C-c[i]]] + v[i])
        2.  f表示前i个物品，在容积为C时最多能装的物品的最大价值。
    2.  二维容器的背包问题，其递推公式：
        1.  f[i,C0,C1] = max(f[i-1, C0-ci[0], C1-ci[1]] + 1, f[i-1, C0, C1])
    3.  注意：
        二维C0和C1需从0到m和n，包括m和n


## 4.Target Sum
1.  题目: 就是用加减符号串联一组整数，为一个算数表达式，求当该表达式==target时，有多少中这样的构造?
2.  解题：
    1.  温故知新：之前做过这个题，用了01背包的思路。
    2.  在探索：今天找了个新解法，遍历二叉树，一支是+一支是-。而这刚好是01背包问题：装还是不装。
    3.  发散思维：如果是一个完整的四则表达式呢，就是有加减乘除都有呢。
    4.  进阶问题：【hard】  Expression Add Operators
    
## 5.Last Stone Weight II
1.  题意：碎任意两块石头，求最后剩下的那个石头的重量
2.  解题：
    1.  按照题意，直接用二叉树求解，超时了。二叉树的确有点野蛮(直接)
    2.  用01背包思想，把问题转化，
        再把背包用法转化：能否凑齐j——这就是一个选择和不选择的问题，只不过不是求最值，
            这一点在递推公式中也能看出来——因为没有max比较计算
    3.  所以，01背包不是求最值，而是装和不装的问题。

## 6.

## 6.12
1.  First Bad Version
    1.  这个题是easy，是折半查找的变形题目，找到第一个坏版本的版本号。
    2.  分析题意：其实输入的就是一个前面是true，后面是false的二值数组，找true和false的分界线。
    3.  我的表现：我的表现是不错的，因为折半查找的框架写的很正确，和标准答案一样。
            那我是凭什么记忆的呢？
    4.  学点什么：
            1.  【mid溢出】尽管我的写法很对，但是却在求mid的时候，没有考虑两数相加溢出的情况，导致有些case报错。

--今天的题目比较简单，就再找两题--
2.  Same Tree
    1.  题意：就是判断两棵树是否是same(包括结构和节点的值)
    2.  太简单了，直接写，不调试.


## 6.15 周二
1.  Peak Index in a Mountain Array
    1.  二分查找就可以了。
    2.  再次强化了二分查找的框架



    